---
layout: post
title: 'JDK中的各种锁'
date: 2019-06-26
author: Sealer
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: JDK 锁 线程安全  多线程

---

## synchronized
　　synchronized关键字是java语言层面的锁，利用jvm自带的指令集（其中的monitorenter和monitorexit）来实现锁的功能，其本质是一种非公平的重入锁。

1. 重入的含义就是某线程在执行时获取了某把锁未释放的情况下，仍需获取相同的锁才能继续执行后续代码，此时无需再次获取锁，可以直接执行加锁逻辑； 
2. 非公平的含义就是不满足先到先得原则，获取不到锁的时候，会自动加入队列，等待线程释放锁后所有等待的线程同时去竞争
　　如果是不可重入锁，下述情况则会死锁：

```java
class Parent {
    public synchronized void doSth() {
        // do parent sth
    }
}

class Child extends Parent {
    @Override
    public synchronized void doSth() {
        super.doSth(); // 此语句需获取未释放的锁才能继续执行， 所以必须为可重入锁
        // do child's sth
    }
}
```

## Lock
　　Lock是JDK1.5开始提供的一个接口， 其共有以下几个方法：
```java
void lock();
void lockInterruptibly() throws InterruptedException;
boolean tryLock();
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
void unlock();
Condition newCondition();
```

　　Lock在JDK中共有以下几种实现：

    1. ReentrantLock
    2. ReadLock in ReentrantReadWriteLock
    3. WriteLock in ReentrantReadWriteLock
    4. ReadLockView in StampedLock
    5. WriteLockView in StampedLock
    6. Segment extends ReentrantLock in ConcurrentHashMap

　　ReentrantLock默认创建的是非公平锁：
```java
public ReentrantLock() {
    sync = new NonfairSync();
}
```

　　使用ReentrantLock默认的非公平锁实现火车站多窗口卖火车票程序。
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 功能描述： $ Main
 *
 * @author sealer
 * @email 1178884049@qq.com
 * @date 2019年06月27日 15时37分00秒
 */
public class Main {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool(new MyThreadFactory("sell_tickets"));
        executorService.submit(new TicketTask());
        executorService.submit(new TicketTask());
        executorService.submit(new TicketTask());
        executorService.submit(new TicketTask());
        executorService.submit(new TicketTask());
        executorService.submit(new TicketTask());
    }
}


class MyThreadFactory implements ThreadFactory {
    private int count = 1;
    private final String prefix;

    public MyThreadFactory(String groupFeature) {
        prefix = "From MyThreadFactory: " + groupFeature + "_";
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread thread = new Thread(r, prefix + (count++));
        return thread;
    }
}

class TicketTask implements Runnable {
    private static final int TICKET_COUNT = 1000;
    private static volatile int count = 0;
    private static final Lock LOCK = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            LOCK.lock();

            try {
                if (count < TICKET_COUNT) {
                    System.out.println(Thread.currentThread().getName() + " : 卖出第" + (++count) + "张票");
                } else {
                    break;
                }
            } finally {
                LOCK.unlock();
            }

            try {
                Thread.sleep(10L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```
## ReadWriteLock
　　ReadWriteLock是JDK1.5开始提供的一个接口， 其共有以下几个方法：
```java
Lock readLock();
Lock writeLock();
```

　　ReadWriteLock在JDK中共有以下几种实现：

    1. ReentrantReadWriteLock
    2. ReadWriteLockView in StampedLock

**_TODO 未完待续。。。_**
