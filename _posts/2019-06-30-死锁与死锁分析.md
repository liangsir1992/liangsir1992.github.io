---
layout: post
title: '死锁与死锁分析'
date: 2019-06-30
author: Sealer
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: java 死锁 死锁分析 Dead Lock   

---

## 什么是死锁？
　　由于两个或者多个线程互相持有对方所需要的资源，导致这些线程均无法得到自身需要的资源，
进入无限期等待，无法继续往下执行。线程之间的这种状态叫做死锁。

## 如何造成死锁？
　　很多面试官在问完死锁的概念后，接下来问的最多的就是：你能不能写一个死锁的程序？
其实，只要弄明白死锁的概念及产生条件，这个问题并不难。

　　**_造成线程间死锁的条件：_**
1. 互斥条件(资源只能同时被一个线程持有)：线程对于所分配到的资源具有排它性，即一个资源只能被一个线程占用，直到被该线程释放； 
2. 请求和保持条件(一个线程拿到资源，不到时候不放手)：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；
3. 不剥夺条件(及资源不可抢占， 只能别人放弃，不可强夺)：任何一个资源在没被该线程释放之前，任何其他线程都无法对它剥夺占用；
4. 循环等待条件(永不言弃， 不能一段时间没得到被占资源就放弃)：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞。

　　明确了上述的几个条件，下面直接上代码了。
```java
public class DeadLock {
    public static void main(String[] args) {
        final Object lock1 = new Object(); // lock1
        final Object lock2 = new Object(); // lock2
        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("t1线程获取了lock1.");
                try {
                    Thread.sleep(50); // sleep 50ms是为了保证在t1获取到lock2之前，lock2能被t2获取到。线程t2的sleep同理。
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println("t1线程又获取了lock2.");
                }
            }

        });

        Thread t2 = new Thread(() -> {
            System.out.println("t2线程获取了lock2.");
            synchronized (lock2) {
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                synchronized (lock1) {
                    System.out.println("t2线程又获取了lock1.");
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```
　　另外补充下线程和进程之间的几点区别：
* 通信的区别

　　线程通信一般是指同一进程内的线程进行通讯，由于在同一进程内，共享地址空间，
因此交互比较容易，全局变量之类的都能起到作用。

　　进程通信一般是指不同进程间的线程进行通讯，由于地址空间不同，因此需要使用
操作系统相关机制进行“中转”，比如共享文件、SOCKET、管道等。

* 实现互斥和同步方式的区别

　　线程之间实现互斥可以使用加锁，例如java里面的synchronized关键字、 Lock等类工具。

　　进程之间实现互斥需要信号量PV操作等。

## 如何分析死锁的堆栈信息？
**_TODO 未完待续。。。_**

## 如何避免死锁？
**_TODO 未完待续。。。_**
